\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsthm}

\usepackage{amsthm,amsmath,amsfonts,amssymb,amstext,enumitem}
\usepackage{latexsym,ifthen,url,rotating,graphicx}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,positioning,fit}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}

\usepackage{hyperref}
\hypersetup{
	colorlinks=false
}



% --- -----------------------------------------------------------------
% --- Document-specific definitions.
% --- -----------------------------------------------------------------
\lstset{
	columns=fixed,
	literate={—}{{---}}1 {…}{{...}}1
}

\newcommand{\todo}[1]{{\color{red}[TODO:{#1}]}}

\newtheorem{problem}{Problem}
\newtheorem{corollary}{Corollary}
\newtheorem{fact}{Fact}
\newtheorem{exercise}{Exercise}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}

\newcommand{\getsr}
{{\:\stackrel{\raisebox{-2pt}{${\scriptscriptstyle \hspace{0.2em}\$}$}}
		{\leftarrow}\:}}
\newcommand{\points}[1]{\textbf{({#1} pts)}}

\newcommand{\fn}{\footnotesize}
\newcommand{\Colon}{\ : \ }
\newcommand{\st}{\mathsf{state}}
\newcommand{\msgs}{\mathcal{M}}
\newcommand{\ctxts}{\mathcal{C}}
\newcommand{\keys}{\mathcal{K}}
\newcommand{\rands}{\mathcal{R}}
\newcommand{\states}{\mathcal{S}}
\newcommand{\kg}{\mathcal{K}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\MAC}{\mathrm{MAC}}
\newcommand{\RMAC}{\mathrm{RMAC}}

\newcommand{\pk}{pk}
\newcommand{\sk}{sk}

\newcommand{\calD}{\mathcal{D}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\AES}{\mathsf{AES}}

\newcommand{\algorithm}[1]{\textbf{Alg} {#1}}

\newcommand{\calO}{\mathcal{O}}

\newcommand{\dlog}{\mathrm{dlog}}

\newcommand{\Adv}{\mathbf{Adv}}
\newcommand{\AdvPRF}[2]{\Adv^{\mathrm{prf}}_{#1}({#2})}
\newcommand{\AdvPRG}[2]{\Adv^{\mathrm{prg}}_{#1}({#2})}
\newcommand{\AdvCPA}[2]{\Adv^{\mathrm{cpa}}_{#1}({#2})}
\newcommand{\AdvCCA}[2]{\Adv^{\mathrm{ind{-}cca}}_{#1}({#2})}
\newcommand{\AdvKR}[2]{\Adv^{\mathrm{kr}}_{#1}({#2})}
\newcommand{\AdvCKR}[2]{\Adv^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\AdvRMR}[2]{\Adv^{\mathrm{rmr}}_{#1}({#2})}
\newcommand{\AdvCR}[2]{\Adv^{\mathrm{cr}}_{#1}({#2})}
\newcommand{\AdvUFCMA}[2]{\Adv^{\textrm{uf{-}cma}}_{#1}({#2})}
\newcommand{\AdvDL}[2]{\Adv^{\mathrm{dl}}_{#1}({#2})}

\newcommand{\Exp}{\mathbf{Exp}}
\newcommand{\ExpOW}[1]{\Exp^{\mathrm{ow}}({#1})}
\newcommand{\ExpCKR}[2]{\Exp^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\ExpRMR}[2]{\Exp^{\mathrm{rmr}}_{#1}({#2})}

\newcommand{\concat}{{\,\|\,}}
\newcommand{\xor}{\oplus}
\newcommand{\bits}{\{0,1\}}

\newcommand{\tcolh}{T^{\mathrm{col}}_h}
\newcommand{\tcolH}{T^{\mathrm{col}}_{H^2}}
\newcommand{\Hcomb}{H^{1\|2}}
\newcommand{\Hxor}{H^{1\oplus2}}

\newcommand{\EXP}{\textrm{EXP}}
\newcommand{\MODEXP}{\textrm{MOD{-}EXP}}
\newcommand{\ADD}{\textrm{ADD}}
\newcommand{\MULTIMODEXP}{\textrm{MULTI{-}MOD{-}EXP}}
\newcommand{\MUL}{\textrm{MUL}}
\newcommand{\MOD}{\textrm{MOD}}

\newcommand{\GG}{\mathbb{G}}
\newcommand{\ZZ}{\mathbb{Z}}

\newcommand{\bK}{\mathbf{K}}
\newcommand{\bof}{\mathbf{f}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bC}{\mathbf{C}}

\newcommand{\rvrange}{\mathcal{R}}
\newcommand{\rspace}{\mathcal{C}}

\newcommand{\hatalpha}{\hat{\alpha}}
\newcommand{\hatb}{\hat{b}}

\newcommand{\barm}{\overline{m}}

\newcommand{\otp}{\mathrm{OTP}}
\newcommand{\des}{\mathrm{DES}}
\newcommand{\twodes}{\mathrm{2DES}}
\newcommand{\threedes}{\mathrm{3DES}}
\newcommand{\threedestwo}{\mathrm{3DES2}}
\newcommand{\aes}{\mathrm{AES}}
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}
\newcommand{\Func}{\mathrm{Func}}


\newcommand{\Img}{\mathrm{Im}}

\newcommand{\Expt}{\mathbf{Expt}}
\newcommand{\ExptCPA}{\mathbf{Expt}^{\mathrm{cpa}}}
\newcommand{\ExptCCA}{\mathbf{Expt}^{\mathrm{cca}}}
\newcommand{\ExptOTCPA}{\mathbf{Expt}^{\mathrm{1\mbox{-}cpa}}}
\newcommand{\ExptOTCPAone}{\mathbf{Expt}^{\mathrm{1\mbox{-}cpa\mbox{-}1}}}
\newcommand{\ExptOTCPAzero}{\mathbf{Expt}^{\mathrm{1\mbox{-}cpa\mbox{-}0}}}
\newcommand{\AdvOTCPA}[2]{\Adv^{\mathrm{1\mbox{-}cpa}}_{#1}({#2})}
\newcommand{\ExptCPAone}{\mathbf{Expt}^{\mathrm{cpa\mbox{-}1}}}
\newcommand{\ExptCPAzero}{\mathbf{Expt}^{\mathrm{cpa\mbox{-}0}}}

\newcommand{\LR}{\mathrm{LR}}

\newcommand{\Piotp}{\Pi_\mathrm{otp}}
\newcommand{\Encotp}{\Enc_\mathrm{otp}}
\newcommand{\Decotp}{\Dec_\mathrm{otp}}
\newcommand{\bhat}{\hat{b}}
\newcommand{\dict}{\mathtt{dict}}
\newcommand{\Col}{\mathsf{Col}}

% --- -----------------------------------------------------------------
% --- Lecture notes formatting macros
% --- -----------------------------------------------------------------

%
% The following commands set up the lecnum (lecture number)
% counter and make various numbering schemes work relative
% to the lecture number.
%
\newcounter{lecnum}
%\renewcommand{\thepage}{\thelecnum-\arabic{page}}
\renewcommand{\thesection}{\thelecnum.\arabic{section}}
\renewcommand{\theexercise}{\thelecnum.\arabic{exercise}}
\renewcommand{\theexample}{\thelecnum.\arabic{example}}
\renewcommand{\thedefinition}{\thelecnum.\arabic{definition}}
\renewcommand{\theequation}{\thelecnum.\arabic{equation}}
\renewcommand{\thefigure}{\thelecnum.\arabic{figure}}
\renewcommand{\thefact}{\thelecnum.\arabic{fact}}
\renewcommand{\thetable}{\thelecnum.\arabic{table}}


%
% The following macro is used to generate the header.
%
\newcommand{\lecture}[2]{
	%\pagestyle{myheadings}
	%\thispagestyle{plain}
	\newpage
	\setcounter{lecnum}{#1}
	\setcounter{page}{1}
	\noindent
	\begin{center}
		\framebox{
			\vbox{\vspace{2mm}
				\hbox to 6.28in { {\bf CMSC 33100 Advanced Operating Systems
						\hfill Winter 2020} }
				\vspace{4mm}
				\hbox to 6.28in { {\Large \hfill #2 \hfill} }
				\vspace{2mm}
				\hbox to 6.28in { {\it Adam Rivkin, Tiago Royer, Aaron Zhang} \hfill }
				\hbox to 6.28in { {\it Instructor: Shan Lu} \hfill }
				\vspace{2mm}}
		}
	\end{center}
	%\markboth{Lecture #1: #2}{Lecture #1: #2}
	\vspace*{4mm}
}





% --- -----------------------------------------------------------------
% --- The document starts here.
% --- -----------------------------------------------------------------
\begin{document}
	%\lecture{**LECTURE-NUMBER**}{**DATE**}{**LECTURER**}{**SCRIBE**}
	\lecture{1}{Drive Encryption Background}
	
	\tableofcontents
	
	\noindent\hrulefill
	\bigskip
	
	Full Disk/Drive Encryption (FDE) is the process of encrypting entire disks or drives. Unlike a lot of computer security which focuses on protecting data-in-transit between a sender and a receiver, FDE is an example of securing data-at-rest on a device in case a phone or laptop is lost or stolen. Since data-at-rest involves a single party securing information for their own later use, FDE primarily uses cryptographic primitives related to symmetric cryptography, where there is a pre-shared key for encryption and decryption.
	
	I don't know how much of a cryptography background you guys have, so I'm going to include a brief summary of the key ideas and definitions which would apply to our project. Feel free to ignore or skim these sections if you're already familiar with the concepts and syntax. I'll start with the two widely-deployed types of algorithms used for symmetric cryptography: block ciphers and stream ciphers. The key idea to the Strongbox paper is that they use a stream cipher for FDE which is unconventional because block ciphers are typically though of as a better fit for encrypting data-at-rest. All the definitions and  \LaTeX\ come from David Cash's cryptography lecture notes, so full credit to him for the next two sections.
	
	\section{Definition of Block Ciphers}
	
	Let's start by defining a cipher in cryptography.
	\begin{definition}
		Let $\keys,\msgs,\ctxts$ be non-empty sets. A function
		\[
		\Enc : \keys\times\msgs \to \ctxts
		\]
		is called a \emph{cipher with key-space $\keys$, message-space
			$\msgs$, and ciphertext-space $\ctxts$} if for every $K\in\keys$,
		the function $\Enc(K,\cdot)$ is one-to-one.
		
		For such a cipher, we define 
		\[
		\Dec: \keys\times\ctxts \to\msgs
		\]
		by letting $\Dec(K,\cdot)$ be the inverse of $\Enc(K,\cdot)$ for
		each $K\in\keys$. (More precisely, $\Dec(k,c)$ is only defined when
		there exits $m\in\msgs$ such that $\Enc(k,m)=c$.)
	\end{definition}
	
	
	So a cipher is an invertible one-to-one function which maps a key and a message to a ciphertext. The definition of a cipher on its own has no security properties. Block ciphers are a subset of ciphers.
	\begin{definition}
		A cipher $E:\keys\times\msgs\to\ctxts$ is called a \emph{block cipher}
		if $\msgs=\ctxts=\bits^\ell$ for some positive integer $\ell$. The integer
		$\ell$ is called the \emph{block length} or \emph{block size} of $E$.
	\end{definition}
	When $E$ is a block cipher, then for each $k\in\keys$, $E(k,\cdot)$ must
	actually be computing a \emph{permutation} on $\bits^\ell$. In practice we will
	always have $\keys=\bits^n$ for some positive integer $n$, and we say that $n$
	is the \emph{key-length} of $E$.
	
	An inuitive way to think about block ciphers is as an extension of substitution ciphers. Substitution ciphers the brain-teasers you might have played when you were younger where each letter of the alphabet is substituted for another letter of the alphabet. In English they're pretty straightforward to break with tricks like a one-letter word needing to correspond to A or I, or the most frequent character likely corresponding to E. Essentially, a substitution cipher is the repeated use of a block cipher where the key is a permutation on the alphabet and the block length is a single letter.
	
	A ``secure'' block cipher is one that ``looks random'' and has a large enough key space that an adversary can't test all possible keys by brute force. Also, there needs to be a method to defend against the idea of using frequency analysis to break the repeated use of a block ciphers with the same key like with substituion ciphers.
	
	We formalize ``looks random'' as pseudorandom function (PRF) security. An adversary, $\calA$, is an algorithm. The adversary gets to pick a message block and then sees either the ciphertext which results from encrypting the block or the output of a pseudorandom function. A ``secure'' block cipher is one where no known adversary exists which can distinguish between encryption and a a pseudorandom function.
	
	\begin{definition}
		Let $E:\bits^n\times\bits^\ell\to\bits^\ell$ and $\calA$ be an adversary.
		Let $\bK$ be uniform on $\bits^n$, and let $\bof$ be a random function
		from $\bits^\ell$ to $\bits^\ell$.
		We define the \emph{pseudorandom function (PRF) distinguishing advantage
			of $\calA$ against $E$} to be
		\[
		\AdvPRF{E}{\calA} =
		\left|\Pr[\calA^{E(\bK,\cdot)}=1]-\Pr[\calA^{\bof(\cdot)}=1]\right|.
		\]
	\end{definition}

Designing a low PRF advantage block cipher is a field in its own. For our purposes, we will assume that the block cipher AES is secure without going into the details of how it operates, treating it as a black box function.

A secure block cipher isn't much use on its own. A call to AES only encrypts a 128-bit block rather than a lengthy message. Encryption schemes $\Pi = (\Enc,\Dec)$ are built on the primitives of block ciphers to encrypt messages of any length. A naive approach to building an encryption scheme would be just divide the message into blocks and call AES on each block. In practice, this is susceptible to the same types of frequency analysis that can be done with substitution ciphers -- the adversary can find damaging information because the same block encrypts to the same ciphertext.

We use the formalization of Chosen Plaintext attacks (CPA) to define security for an encryption scheme. Here the adversary gets to pick two equal length messages and then sees the result after either the first or second message is encrypted. After this happens many times, the adversary guesses whether the first or second message is the one being encrypted. 

\begin{definition}
	Let $\Pi = (\Enc,\Dec)$ be a randomized encryption scheme with key-space
	$\keys$, message-space $\msgs$, randomness-space $\rands$, and
	ciphertext-space $\ctxts$.  We assume that the message-space $\msgs$ is a
	set of bit strings, i.e.  $\msgs\subseteq\bits^*$.  Let $\calA$ be an
	algorithm. Define algorithm $\ExptCPA_\Pi(\calA)$ as
	\begin{center}
		\begin{tabular}{c}
			\begin{minipage}{2in}\begin{tabbing}
					123\=123\=\kill
					\underline{\algorithm{$\ExptCPA_\Pi(\calA)$}} \\[2pt]
					\fn01 \> Pick $k\getsr \keys, b\getsr \bits$\\
					\fn02 \> Run $\calA^{\LR_{k,b}(\cdot,\cdot)}$, where the oracle
					is given below. Eventually $\calA$ halts with output $\hatb$\\
					\fn03\> If $\hatb = b$: Output 1\\
					\fn06 \> Else: Output 0\\
					\\
					\underline{Oracle $\LR_{k,b}(m_0,m_1)$} \\
					\> If $m_0,m_1$ are not the same length: Return $\bot$\\
					\> Pick $r \getsr \rands$\\
					\> Compute $c \gets \Enc(k,m_b,r)$\\
					\> Return $c$
			\end{tabbing}\end{minipage}
		\end{tabular}
	\end{center}
	Define the \emph{CPA advantage of $\calA$ against $\Pi$} as
	\[
	\AdvCPA{\Pi}{\calA} =
	\left|\Pr[\ExptCPA_\Pi(\calA) = 1] - \frac{1}{2}\right|
	\]
\end{definition}

Proving CPA security is done by reducing faith in the security of an encryption scheme to faith in the security of the block cipher used in the scheme. This is a tricky process which shows that an adversary which can win the CPA game must also be able to distinguish between the block cipher used in the CPA and a PRF. Therefore, $\AdvCPA{\Pi}{\calA} \leq \AdvPRF{E}{\calB}$, so if the block cipher is secure, the encryption scheme will also be secure. An example of such a reduction is given below (its somewhat convulated but interesting if you want to read through it).

\begin{theorem}
	Let $E:\bits^n\times\bits^\ell\to\bits^\ell$ be a block cipher. 
	Define a randomized encryption encryption scheme 
	$\Pi=(\Enc,\Dec)$ with key-space $\bits^n$, message-
	and randomness-spaces $\msgs=\rands=\bits^\ell$, and ciphertext-space
	$\ctxts=\bits^\ell\times\bits^\ell$ by
	\[
	\Enc(k,m,r)=(r,E(k,r)\oplus m)
	\]
	and $\Dec(k,(r,c)) = E(k,r)\oplus c$. Then for every $\calA$ there
	exists a $\calB$, running in about the same time as $\calA$, such
	that
	\[
	\AdvCPA{\Pi}{\calA} \leq \AdvPRF{E}{\calB} + \Col(2^\ell,q),
	\]
	where $q$ is the number queries issued by $\calA$.
\end{theorem}
\begin{proof}
	We construct the needed adversary $\calB$, which has access to an oracle
	$\calO$ that is either $E$ with a random key, or a random function $f$.
	The high-level idea is similar to the reduction to PRG security for
	one-time CPA, in that $\calB$ will need to ``simulate'' the CPA game for
	$\calA$. The main differences for the simulation are that $\calB$ has an
	oracle instead of an input, and the scheme $\Pi$ under consideration is
	randomized rather than deterministic. The similarity is that we want
	$\calB$, when connected to the oracle $E(\bK,\cdot)$, to simulate
	\emph{exactly} $\ExptCPA_{\Pi}(\calA)$, while if the oracle is
	$\bof(\cdot)$ then we want to simulate a game that $\calA$ can't win
	too often.
	
	Our $\calB$ has access to an oracle $\calO(\cdot)$ mapping $\bits^\ell$ to
	$\bits^\ell$; It is trying to determine if $\calO(\cdot)=E(\bK,\cdot)$
	or $\calO(\cdot)=\bof(\cdot)$.
	
	The adversary $\calB^\calO$
	picks a bit $b$ and runs $\calA$. 
	When $\calA$ queries $\LR_{k,b}(m_0,m_1)$,
	$\calB$ picks $r\in\bits^\ell$ and returns
	\[
	(r, \calO(r)\oplus m_B).
	\]
	Eventually when $\calA$ halts with bit $\hat{b}$, if $\hat{b}=b$ then
	$\calB$ outputs $1$, and otherwise it outputs $0$. This completes
	the description of $\calB$.
	
	We first claim that 
	\[
	\Pr[\calB^{E(k,\cdot)}=1] = \Pr[\ExptCPA_{\Pi}(\calA)=1],
	\]
	because in this case $\calB$ exactly simulates the experiment
	for $\calA$. That is, every oracle query is processed \emph{exactly}
	as in $\ExptCPA_{\Pi}(\calA)$ (and in particular a random key and bit are
	chosen, and each query uses a uniform and independent $r$ in addition to
	following the algorithm). Finally the output bit of $\calB$ is determined
	in exactly the same way.
	
	We next claim that
	\[
	\Pr[\calB^{f(\cdot)}=1] = \frac{1}{2} - \Col(2^\ell,q)
	\]
	where $q$ is the number of oracle queries issued by $\calA$.  Intuitively,
	with this oracle, $\calB$ is using a ``fresh one-time pad'' to mask every
	query response \emph{as long the $r$ does not repeat}. To formalize
	this a little bit,  let $R$ be the event that $\calB$ chooses the
	same value of $r$ in two different queries. Then $\Pr[R] = \Col(2^\ell,q)$.
	Writing $\bar{R}$ for ``not $R$'' and using the law of total probability,
	\begin{align*}
	\Pr[\calB^{f(\cdot)}=1] 
	& = \Pr[\calB^{f(\cdot)}=1|R]\Pr[R] 
	+ \Pr[\calB^{f(\cdot)}=1|\bar{R}]\Pr[\bar{R}]  \\
	& \leq \Pr[R] 
	+ \Pr[\calB^{f(\cdot)}=1|\bar{R}] \\
	& \leq \Col(2^\ell,q) + \frac{1}{2}. 
	\end{align*}
	The first inequality follows because we just omit some factors which are
	both probabilities and thus at most $1$. In the second inequality,
	we use $\Pr[R]=\Col(2^\ell,q)$ for the first part. To complete this
	we need to justify
	\begin{align*}
	\Pr[\calB^{\bof(\cdot)}=1|\bar{R}] = \frac{1}{2}. 
	\end{align*}
	Actually doing this completely rigorously is tricky. The key observation
	is that, if $R$ does not happen, that means all of queries are processed
	with unique values of $r$. Call them $r_1,\ldots,r_q$. Then the $i$-th
	query is answered with
	\[
	(r_i, \bof(r_i)\oplus m_b).
	\]
	But, conditioned on $R$ not happening,
	$\bof(r_1),\bof(r_2),\ldots,\bof(r_q)$ are all uniform and independent
	random variables on $\bits^\ell$. Thus each query completely masks out
	the message $m_b$, and hence are independent of $b$. Since every query
	response is independent of $b$, the adversary $\calA$ produces an output
	independent of $b$. Thus the probability that $\bhat=b$ is $1/2$, and
	this is the probability that $\calB$ outputs $1$.
	
	Finally, the rest is calculation:
	\begin{align*}
	\AdvPRF{E}{\calB} 
	& = |\Pr[\calB^{E(\bK,\cdot)}=1] - \Pr[\calB^{\bof(\cdot)}=1]| \\
	& \geq  \Pr[\calB^{E(\bK,\cdot)}=1] - \Pr[\calB^{\bof(\cdot)}=1] \\
	& =  \Pr[\ExptCPA_{\Pi}(\calA)=1] - \Pr[\calB^{\bof(\cdot)}=1] \\
	& \geq  \Pr[\ExptCPA_{\Pi}(\calA)=1] - \frac{1}{2} - \Col(2^\ell,q).
	\end{align*}
	The proof is completed by rearranging the final inequality.
\end{proof}
	
	\subsection{Tweakable Block Ciphers}
	
	Tweakable block ciphers are block ciphers that take three parameter, $\keys$, $\msgs$, and $\tau$ where $\tau$ is a tweak. Instead of the block cipher being a single pseudo-random permutation, a tweakable blockcipher is $2^{|\tau|}$ pseudo-random permutation ($|\tau|$ is the number of bits in $\tau$). I haven't studied these much, but AES-XTS, which is normally used for disk encryption is tweakable block cipher, so we should get to understand them better.
	
	\section{Definition of Stream Ciphers}
	
	
	\section{Application to Disk Encryption}

	\section{Strongbox and New Directions}
	
	\subsection{Links to Relevant Papers}
	
	For our related works section:
	
	\begin{description}[font=$\bullet$~\normalfont\scshape\color{red!50!black}]
		\item \href{https://ieeexplore.ieee.org/abstract/document/6951337}{A Systematic Assessment of the Security of Full Disk Encryption} -- Overview of disk encryption
		\item \href{https://people.eecs.berkeley.edu/~daw/papers/tweak-joc.pdf}{Tweakable Block Ciphers} -- Definition of tweakable block ciphers
		\item \href{https://ieeexplore.ieee.org/abstract/document/6945842}{STES: A Stream Cipher Based Low Cost Scheme for Securing Stored Data} -- Another scheme that uses stream ciphers for disk encryption, but also a rabbit hole I don't want to go too far down
		\item \href{https://eprint.iacr.org/2018/720}{Adiantum: length-preserving encryption for
			entry-level processors} -- A recent Google paper which also uses stream ciphers for disk encryption. This one needs some attention
		\item \href{}{}
	\end{description}
	
	
	
\end{document}