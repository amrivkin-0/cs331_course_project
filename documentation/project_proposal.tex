\documentclass[11pt,twocolumn]{article}
\usepackage[colorlinks=true]{hyperref}
\usepackage{amsmath}

\newcommand\Enc{\mathsf{Enc}}
\newcommand\Dec{\mathsf{Dec}}

\begin{document}
	
	\title{
		Rewrite-Resistant Block Ciphers for Full Drive Encryption
	}
	\date{January 28th, 2020}
	\author{Adam Rivkin, Tiago Royer, Aaron Zhang}
	\maketitle
	
	\begin{abstract}
		Full-Drive Encryption (FDE) is the process of encrypting the entire drive of a machine. The standard approach to FDE implements encryption using tweakable block ciphers, where the tweak for each block is its position within the disk sector. Since the tweak for a block position never changes, a certain plaintext block written to the same disk position is always mapped to the same ciphertext. Therefore, an adversary can detect data being written twice to the same block location. While stream cipher based FDE schemes exist which provide security against this type of vulnerability through the use of nonces, they perform poorly with write-heavy file systems. Our goal is to adapt a block cipher based scheme so that rewrites of previously occurring data cannot be detected.
	\end{abstract}
	
	\section*{Introduction}
	
	Full-Drive Encryption encrypts the drive of machine to protect data in case a device is physically lost or stolen. FDE implementations typically perform encryption within the operating systems at kernel-level or with hardware inside the drive ~\cite{muller2014systematic}. Standard encryption techniques must be modified for FDE because of the difficulty of finding a secure way to store a MAC or nonce, and the limitation that the ciphertext must be an equal length to the plaintext.
	
	The security standard for encrypting data-in-transit ensures that the same messages encrypted twice lead to different ciphertexts through the use of an initialization vector, tweak, or nonce. However, in the case of most FDE implementations this standard is not met because the same data written twice to the same disk location will give the same result. While not immediately harmful, this side channel leakage could lead to further exploits and fails the level of confidentiality normally provided by provable security. We aim to present a block cipher based FDE implementation which will hide disk rewrites from an adversary.
	
	\section*{Background}
	
	Symmetric ciphers are usually divided into two broad categories: block ciphers and stream ciphers.
	A block cipher is essentially a pair of functions $\Enc$ and $\Dec$
	(for encryption and decryption, respectively)
	that takes a key and a fixed-length binary string
	and produces a string,
	such that
	\begin{equation*}
	\Dec(\mathrm{key}, \Enc(\mathrm{key}, \mathrm{data})) = \mathrm{data}
	\end{equation*}
	for all valid choices of key and data block.
	AES (Advanced Encryption Standard) is an example of block cipher;
	it operates as a pseudo-random permutation on strings of 128 or 256 bits.
	In order to cipher longer messages,
	the message is divided into blocks equal to the input size of AES, and each block is ciphered separately according to a mode of operation which obstructs against frequency analysis.
	
	Stream ciphers, on the other hand,
	are essentially pseudorandom number generators.
	Given a key,
	the stream cipher produces an sequence of bits
	(the keystream), which is used as a one-time pad.
	In order to cipher a message $m$,
	we let the first $|m|$ bits generated by the cipher be $s$,
	and compute $m \oplus s$
	(the bit-wise exclusive-or of the message and the keystream).
	
	In the context of full-disk encryption,
	we have a large piece of data which we want to encrypt.
	Because sectors of the disk may need to be rewritten,
	conventionally block ciphers are used for FDE.
	Using a stream cipher would entail changing the key in every overwrite,
	so as to avoid the security problems of reusing the same one-time pad.
	While stream ciphers are usually faster to compute,
	the overhead of re-keying the stream cipher is usually deemed too costly.
	
	A recent paper~\cite{StrongBox2018} develops a stream cipher
	that circumvents the performance penalty of rekeying.
	StrongBox achieves both efficiency and security by using recent developments in SSD hardware.
	Efficiency makes use of flash translation layers (FTL),
	while security relies on replay-protected memory blocks (RPMB).
	The FTL is designed for wear leveling and distributes writes among the disk sectors.
	As a result, fewer sectors are overwritten compared to filesystems like Ext4.
	
	The efficiency of StrongBox relies on having a filesystem that supports FTL
	or operates like a log-structured filesystem to reduce the number of overwritten disk sectors.
	The authors of StrongBox tested their implementation on the F2FS filesystem,
	which is a modern log-structured filesystem.
	Compared to the standard AES-XTS on Ext4,
	encrypted reads on StrongBox were about twice as fast on average.
	Encrypted writes performed at about the same speed or slightly better on average,
	despite the need for occasional rekeying.
	On the other hand, when the authors tested StrongBox on Ext4,
	it was significantly slower than AES-XTS.
	
	An additional security property of StrongBox
	is that if the filesystem decides to write the same block of data to the same sector,
	the encrypted data will be different in each write.
	Detecting that the same data was written to the same place
	might leak important information,
	even if the plain data itself is not recoverable from the encrypted block.
	We can understand this vulnerability in terms of a high advantage chosen-plaintext adversary.
	
	\section*{Proposal}
	
	We want to modify a block cipher based FDE scheme
	so that it provides the same security guarantees as StrongBox.
	
	Specifically,
	we want to develop a block cipher based on the AES-XTS algorithm
	that is secure against rewriting to the same disk sector block position.
	This entails specifying the ciphering and deciphering algorithms,
	formalizing what it means for a cipher to be ``secure against rewrites'',
	and prove that our algorithm satisfies the definition.
	
	In order to test practicality,
	we will implement our cipher
	and compare its runtime against StrongBox and the unmodified AES-XTS.
	Specifically,
	we want to compare the performance of our algorithm on Ext4,
	where the performance of StrongBox is worse than AES-XTS.
	
	Also, in order to justify this implementation,
	we want to find examples in which rewrites leak important information.
	
	\section*{Milestones and Timeline}
	
	\subsection*{Success Metrics}
	We will measure the success of our implementation by comparing the read and write performance of our rewrite-resistance block cipher implementation to dm-crypt with AES-XTS and StrongBox on a non-LFS file system.
	
	\subsection*{Timeline}
	
	\begin{itemize}
		\item Weeks 4--5: Complete a literature review of disk encryption and formalize the security model
		\item Week 5: Document examples of rewrite leaks and file systems where StrongBox would perform poorly
		\item Weeks 4--6: Develop our re-write resistant ciphering and deciphering algorithms
		\item Week 6: Provide formal proofs that our algorithm satisfies the security guarantees.
		\item Weeks 7--8: Implement the algorithms. Run dm-crypt and StrongBox from publicly available code for comparison.
		\item Week 9: Run the performance tests and visualize results
		\item Week 10: Final presentation and paper writing
	\end{itemize}
	
	\subsection*{Publicly Available Code}
	We plan to build our implementation of a rewrite-resistant block cipher disk encryption scheme on two publicly available sources of code: dm-crypt and StrongBox. We will use dm-crypt, a block cipher based disk encryption subsystem for the Linux kernel, as the basis of our implementation and draw on StrongBox as an example of the metadata used in a rewrite-resistant scheme.
	
	The source code for dm-crypt is freely available at \url{https://gitlab.com/cryptsetup/cryptsetup/-/wikis/DMCrypt}.
	
	Dicken's et al.'s implementation of StrongBox is publically available at \url{https://git.xunn.io/closed-source/research/psd-mirrored/buselfs}.
	
	\bibliographystyle{plainurl}
	\bibliography{bibliography}
	
\end{document}
